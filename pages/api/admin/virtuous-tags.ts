import { NextApiRequest, NextApiResponse } from 'next'
import { supabaseAdmin } from 'lib/supabase/client'
import { Resend } from 'resend'

const resend = new Resend(process.env.RESEND_API_KEY)

interface VirtuousTag {
  id: number
  tagName: string
  tagGroupName: string
  contactsByTagUrl: string
}

interface TagLookupResult {
  found: boolean
  tagId?: number
  cached?: boolean
}

/**
 * Look up a tag in Virtuous and cache it locally
 */
async function lookupAndCacheTag(tagName: string): Promise<TagLookupResult> {
  try {
    // First check our local cache
    const { data: cachedTag, error: cacheError } = await supabaseAdmin
      .from('virtuous_tags')
      .select('virtuous_tag_id')
      .eq('tag_name', tagName.toLowerCase())
      .single()

    if (!cacheError && cachedTag) {
      return {
        found: true,
        tagId: parseInt(cachedTag.virtuous_tag_id),
        cached: true
      }
    }

    // Not in cache, look up in Virtuous (get all tags with pagination)
    const virtuousResponse = await fetch('https://api.virtuoussoftware.com/api/Tag?take=100', {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${process.env.VIRTUOUS_API_KEY}`,
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      }
    })

    if (!virtuousResponse.ok) {
      console.error('Failed to fetch tags from Virtuous:', virtuousResponse.status)
      return { found: false }
    }

    const response = await virtuousResponse.json()
    const tags: VirtuousTag[] = response.list || response
    const foundTag = tags.find(tag =>
      tag.tagName.toLowerCase() === tagName.toLowerCase()
    )

    if (foundTag) {
      // Cache the tag for future use
      await supabaseAdmin
        .from('virtuous_tags')
        .upsert({
          tag_name: tagName.toLowerCase(),
          virtuous_tag_id: foundTag.id.toString(),
          updated_at: new Date().toISOString()
        })

      return {
        found: true,
        tagId: foundTag.id,
        cached: false
      }
    }

    // Tag not found - send error email
    await sendTagNotFoundEmail(tagName)
    return { found: false }

  } catch (error) {
    console.error('Error looking up tag:', error)
    return { found: false }
  }
}

/**
 * Send error email when tag is not found
 */
async function sendTagNotFoundEmail(tagName: string) {
  try {
    const recipients = [
      'mtapia@gracewoodlands.com',
      'jonathan@jpierce.dev', 
      'jpierce@gracewoodlands.com'
    ]

    const emailHtml = `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <h2 style="color: #dc2626;">Virtuous Tag Not Found</h2>
        <p>A user attempted to subscribe with a marketing source tag that doesn't exist in Virtuous.</p>
        
        <div style="background-color: #fef2f2; border: 1px solid #fecaca; padding: 16px; border-radius: 8px; margin: 16px 0;">
          <h3 style="color: #dc2626; margin-top: 0;">Missing Tag Details:</h3>
          <p><strong>Tag Name:</strong> ${tagName}</p>
          <p><strong>Time:</strong> ${new Date().toLocaleString()}</p>
        </div>

        <h3>Action Required:</h3>
        <p>Please create the tag "${tagName}" in Virtuous if it should exist, or verify the marketing campaign is using the correct tag name.</p>
        
        <p style="color: #6b7280; font-size: 14px; margin-top: 24px;">
          This email was automatically generated by the Forge Journal marketing attribution system.
        </p>
      </div>
    `

    await resend.emails.send({
      from: 'The Forge Journal <notifications@theforgejournal.com>',
      to: recipients,
      subject: `Missing Virtuous Tag: "${tagName}"`,
      html: emailHtml,
    })

    console.log(`Sent tag not found email for: ${tagName}`)
  } catch (error) {
    console.error('Failed to send tag not found email:', error)
  }
}

/**
 * Apply tags to a Virtuous contact
 */
export async function applyVirtuousTags(contactId: number, tagNames: string[]): Promise<void> {
  console.log(`Applying ${tagNames.length} tags to contact ${contactId} sequentially:`, tagNames)

  // Apply tags sequentially with delays to avoid rate limiting
  for (let i = 0; i < tagNames.length; i++) {
    const tagName = tagNames[i]

    try {
      const result = await lookupAndCacheTag(tagName)

      if (result.found && result.tagId) {
        const tagResponse = await fetch('https://api.virtuoussoftware.com/api/ContactTag', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${process.env.VIRTUOUS_API_KEY}`,
            'Content-Type': 'application/json',
            'Accept': 'application/json'
          },
          body: JSON.stringify({
            contactId: contactId,
            tagId: result.tagId
          })
        })

        if (tagResponse.ok) {
          console.log(`Successfully applied tag "${tagName}" (ID: ${result.tagId}) to contact ${contactId}`)
        } else {
          console.error(`Failed to apply tag "${tagName}":`, await tagResponse.text())
        }

        // Add delay between tag applications (except for the last one)
        if (i < tagNames.length - 1) {
          console.log(`Waiting 750ms before applying next tag to avoid rate limiting...`)
          await new Promise(resolve => setTimeout(resolve, 750))
        }

      } else {
        console.log(`Tag "${tagName}" not found in Virtuous - email notification sent`)
      }
    } catch (error) {
      console.error(`Error applying tag "${tagName}":`, error)
    }
  }

  console.log(`Completed applying all tags to contact ${contactId}`)
}

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  if (req.method === 'GET') {
    // Get all cached tags
    try {
      const { data: tags, error } = await supabaseAdmin
        .from('virtuous_tags')
        .select('*')
        .order('tag_name')

      if (error) throw error

      return res.status(200).json({
        success: true,
        data: tags
      })
    } catch (error) {
      return res.status(500).json({
        success: false,
        error: 'Failed to fetch cached tags'
      })
    }
  }

  if (req.method === 'POST') {
    // Manually lookup and cache a tag
    const { tagName } = req.body

    if (!tagName) {
      return res.status(400).json({
        success: false,
        error: 'tagName is required'
      })
    }

    try {
      const result = await lookupAndCacheTag(tagName)
      return res.status(200).json({
        success: true,
        data: result
      })
    } catch (error) {
      return res.status(500).json({
        success: false,
        error: 'Failed to lookup tag'
      })
    }
  }

  return res.status(405).json({ error: 'Method not allowed' })
}
